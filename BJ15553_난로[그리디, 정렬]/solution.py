'''
성냥 갯수가 친구 수보다 이상이면, 걍 다 껏다 키면 되는데
그럴일은 잘 없을 거고
성냥 갯수가 부족한 만큼
친구와 친구사이의 간격이 짧은걸 묶어줘야할거같은데

간격을 구하는건 맞다
성냥의 개수만큼의 뭉탱이를 받을 수 있으니,
친구들을 묶되 성냥의 갯수 만큼을 만들어야 최소 시간으로 보일러를 키게 된다
그럼 몇개의 친구들을 묶어야 성냥의 개수만큼 뭉탱이로 만들어지나?
10명의 친구들을 3개의 그룹으로 만들어야한다면,
7번 묶는 작업을 해주어야 3개의 그룹으로 남게된다.
고로 N-K번 붙여주어야하고, 간격 리스트에서 sort하여 가장 작은 간격을 순서대로 붙여주어야
가장 적은 시간으로 모든 친구들을 받을 수 있게 된다.

'''

import sys

input = lambda : sys.stdin.readline().strip()

N, K = map(int, input().split())

friends = []
for i in range(N):
    a = int(input())
    
    if i == 0 :
        friends.append([a, 0])
    else :
        #간격을 1씩 빼준건
        #기본적으로 친구들을 모두 받아야하고
        #답에 미리 N만큼의 시간을 더해놓을 거기 때문이다.
        friends.append([a, a-friends[i-1][0]-1])

#가장 먼저오는 애는 신경 쓸 필요없다
friends = friends[1:]

friends.sort(key=lambda x : x[1])

# print(friends)

#사람의 수만큼 기본적으로 각 1시간씩 차지하니까
#ans는 N을 기본적으로 가진다.
ans = N
#양초의 개수만큼 그룹을 이뤄야지만 가능하고
#그러기 위해서 간격을 붙여야하는건 전체인원에 양초 개수를 뺀
#수 만큼 친구를 붙여야한다.
#10명의 친구를 3개의 그룹(양초)으로 만들려면 7번을 붙여야한다.
for i in range(N-K):
    ans += friends[i][1]

print(ans)